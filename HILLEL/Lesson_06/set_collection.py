#множества - хранят только уникальные значения
import random

s={4,6,'Hello', True}
print(s, type(s))

s={} #так нельзя создать пустое множество, создается словарь
print(s, type(s))

s = set() # так можно
print(s, type(s))

s = set('Hello World!')
print(s, type(s))
#  никаких индексов и срезов во множествах нет инсерт и делит не работают

for element in s:
    print(element, end=' ')
print()

#add - добавление в сет, место произвольно
s.add(56)
print(s)
s.add(56) #повторное добавление не меняет сет
print(s)

#remove и discard
s.remove('W')
print(s, 'убрали W')
#s.remove('a') #вызывает ошибку если такого элемента нет внутри множества
#print(s)

s.discard('e')
print(s, 'убрали discard букву  e')
s.discard('A') # не вызывает ошибку если такого нет
print(s, 'повторный discard "e" не вызывает ошибки')

x = s.pop() # нет индекса так-как это множество, вытаскивает из множества
# одно случайное занчение, уменьшая множество
print(x)
print(s)



# s1= {random.randint(10,90) for _ in range (15)}
# s2= {random.randint(10,90) for _ in range (15)}
# упорядывачить и сортировать сеты бесполезно
# генерируемые сеты могут иметь разную длину, если элементы повторяются
s1 = {10, 32, 68, 71, 26, 40, 74, 12, 45, 48, 83, 25, 90, 62}
s2 = {66, 70, 38, 10, 71, 81, 12, 74, 86, 24, 26, 31, 83, 63}

print(s1, len(s1)) # len даст список неповторяющихся элементов из руками данного множества
print(s2, len(s2))

# A|B       A.union(B) сами сеты не меняются
# A|=B      A.update(B)

s3 = s1 | s2
print(s3, 'список элементов принадлежащих обоим множествам без повторов') #остались только уникальные элементы

# A & B     A.intersection(B) #  только повторяющиеся элементы
# A &=B     A.intersection_update(B)

s3 = s1 & s2
print(s3, 'только эл-ты принадлежащие обоим множествам')

# A-B       A.difference(B)  #элементы которые есть в первом но нет во втором
# A-= B     A.difference_update(B)

s3 = s1 - s2
print(s3, 'элементы которые есть в первом, но нет во втором')

# A ^ B     A.symmetric_difference(B)   # объединение вместе эл-тов которые
                                        # уникальны для каждого множества
# A^= B     A.symmetric_difference_update(B)
s3 = s1 ^ s2
print(s3)
# описание симметричной разницы:
sx = s1 - s2 # эл-ты которые есть в первом, но нет во втором
sy = s2 - s1 # эл-ты которые есть во втором, но нет в первом
sz = sx | sy # объединение множеств
print(sz)

print(s3==sz, 'проверка равности 2-х множеств')

sa = {1,2,3,4}
sb = {1,2,2,3,4}
print(sa, sb, sa==sb, 'эти мн-ва равны')

sa = {1,2,3,4,5}
sb = {1,2,2,3,4}
print(sa, sb, sa==sb, 'эти нет')

# неизменяемый сет, к нему можно применять только функции которые не меняют сет
fs = frozenset(s1)
print(fs, type(fs))