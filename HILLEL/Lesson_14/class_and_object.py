"""
class ClassName(ParentName1, ParentName2 ...):
    body_class
class ClassName:
    body_class

принципы ООП:
- наследование
- полиморфизм: разные объекты разных классов могут иметь одинаковый/единый интерфейс управления
- инкапсуляция: сокрытие внутренней реализации и предоставление пользователю
только некоторого открытого ему интерфейса. пользователь не сможет вмешиваться в
работу объекта, а только взаимодействовать с ним разрешенными для него методами.
- абстракция: нас интересует только функционал объекта, а не его внутреннее устройство

класс - это чертёж/описание на базе которого можно создавать любое количество объектов
Объект характеризуется
- атрибутами которые описывают состояние объекта
- поведением - что мы можем делать с объектом и что он будет при этом выполнять
"""


class Point:  # название класса - КэмэлКейсСтайл
    A = 10  # тело класса атрибуты - то что описывает состояние объекта, нужно или
    # объявить тип(int, float) или присвоить значение
    B = 11  # это атрибуты класса - они одинаковы для всех объектов класса
    name = 'Point'

    # методы - то что описывает поведение объекта, они принадлежат объекту и вызываются через объект
    # магические методы:  __gt__, __add__, __str__  - вызываются автоматически
    # самодельные методы нужно вызывать вручную (см Show)

    def __init__(self, x=0, y=0):  # инициализатор (конструктор), который включается в момент
        # создания объекта данного класса и предназначен для инициализации атрибутов
        # объекта, которые могут или передаваться или указываться по умолчанию,
        # но тогда умолчания нужно указать в методе (x=0). конструктор в классе может быть только один
        if 5 <= x <= 10:
            self.x = x  # это атрибуты объекта - они персонифицированы для каждого создающегося объекта
        else:
            self.x = x % 10
        self.y = y

    def setx(self, x):  # сеттер метод для изменения состояния объекта - они применяются для
        # ограничения доступа пользователя к объектам
        if 5 <= x <= 10:  # Если значение попадает в диапазон 5-10, то мы меняем параметр,
            # если не попадает, то параметр не меняем
            self.x = x

    def getx(self):  # геттер метод для получения состояния объекта - они применяются для
        # ограничения доступа пользователя к объектам
        return self.x

    def __gt__(self, other):  # метод сравнения 2-х объектов
        if self.x > other.x and self.y > other.y:  # описывается каким образом выполняется сравнени
            return True
        else:
            return False

    def __add__(self, other):  # операция сложения 2-х объектов
        return Point(self.x+other.x, self.y+other.y)

    def __str__(self):  # метод применяемый когда объект приводится к типу строка,
        # например при печати. Если его нет выведется адрес объекта в памяти
        return f'x = {self.x}, y = {self.y}'

    def show(self):  # самодельный  метод-пример, который нужно вызывать вручную
        print(f'Point({self.x}, {self.y})')

    # def plus(self, a = 0):
    #     return self.x = a + 1

    @staticmethod  # статический метод, объявляется внутри класса с декоратором @staticmethod
    # статический метод может вызываться через класс или через объект
    # но сам он не может получить доступ ни к атрибутам класса (А, В), ни к атрибутам объектов (х, у)
    # статический метод принадлежит классу, но не является элементом саомго класса
    # он работает как обычная функция объявляемая в модуле, однако принадлежит пространству имён класса, а не модуля
    def mult(i, j):
        return i + j


pt = Point()  # инициализация объекта класса Поинт, если не будет скобок - pt  станет 2-м именем класса поинт
# (!!!! если не создан инициализатор, то значения переменных можно не передавать, если создан, нет значений по умолчанию
# и не передать - будет ошибка)
print(pt.A)  # смотрим А-атрибут класса

print(pt.x)  # смотрим x-атрибут объекта pt заданный по умолчанию
pt.A = 4  # доступ к атрибутам обекта
print('доступ к атрибутам обекта A =4:', pt.A)

pt = Point(6)  # - тут мы объявили (через __init__)объект pt c атрибутами
# объекта x=6,y=5. Атрибуты класса A,B остались неизменными
print('pt = Point(6, 5), печатем pt.A, pt.B - они остались прежними:   ', pt.A, pt.B)

Point.A = 23  # доступ к А-параметру через класс класса и все дальнейшие объекты будут создаваться с новым параметром
print('новый параметр А:', Point.A)
print('x param of pt obj:', pt.x)  # печатаем х параметр объекта pt

pt1 = Point()
pt2 = Point()
print('object pt1, param A:', pt1.A)
print('object pt1, param A:', pt2.A)
print('type of pt1, pt2:', type(pt1), type(pt2))  # main означает что класс поинт запущен из скрипта, не из модуля
print('id pt1, id pt2:', id(pt1), id(pt2))  # тип один, но id разные, изменения в объекте pt1 не затронут объект 2

print(pt.A)  # у всех объектов А-парам одинаков
print(pt1.A)
print(pt2.A)

pt.A = 45  # невозможно обратиться к атрибуту класса через объект
# создается новый атрибут данного объекта с тем же именем, который затеняет,
# делает недоступным для данного объекта атрибут класса
print(pt.A)  # атрибут А класса Поинт для объекта pt стал новым атрибутом объекта pt (теперь
# для pt восстановить доступ к атрибуту А класса Поинт невозможно)
# - это особенность Питона, можно на ходу добавлять в объект новые атрибуты и новые методы
pt.A1 = 38  # еще один атрибут
print(dir(pt))  # они все появятся в строке dir

print(pt1.A)  # у всех остальных он остался прежним
print(pt2.A)
print(Point.A)  # при этих манипуляциях атрибут класса остался прежним

pt.B = 88  # то же самое
print('dir Point:', dir(Point))
print('dir pt:', dir(pt))
print('dir pt1:', dir(pt1))


class T:
    """
    Instance of class T
    """

    def func(self):
        self.d = 9


t = T()
print(' dir пустого класса T:', dir(T))
print('dir объекта t класса T:', dir(t))
print('dict класса Т: ', T.__dict__)  # словарь методов и атрибутов конкретного объекта:
# main - в каком модуле объявлен этот класс, его док-стринг, его функции
print("t", t.__dict__)
# специальные методы которые видны из dir:
# __init__ - метод создания объекта и его инициализации
# __gt__ - метод вызывается когда к 2-м объектам одного класса мы применяем оперцию больше
# __eq__ - метод который вызывается когда к 2-м объектам класса применятется оперция строгого равенства
print(" pt dict", pt.__dict__)  # показывает аттрибуты объекта
print('Point dict:', Point.__dict__)

pt1.x = 3
pt1.y = 2

print('сравнение pt1.x > pt2.x: ', pt1.x > pt2.x)  # мы спокойно можем сравнивать атрибуты объектов
print('сравнение pt1.x > pt2.y: ', pt1.x > pt2.y)  # даже разные аттрибуты,
# то есть мы просто сравниваем числовые значения разных аттрибутов

print('pt1 x, y:', pt1.x, pt1.y)
print('pt2 x, y:', pt2.x, pt2.y)
print('сравнение pt1 и pt2 через __gt__:', pt1 > pt2)

pt3 = pt1 + pt2  # сложение через __add__ и присвоение результатов новой переменной
print('печать параметров новой переменной pt3:', pt3.x, pt3.y)  # печать параметров новой переменной pt3
print('печать pt3 через __str__: ', pt3)  # печать pt3 через __str__

pt4 = Point(pt1.x+pt2.x, pt1.y+pt2.y)  # cложение объектов без __add__
print('результат cложения объектов без __add__:', pt4)

pt4.show()  # самодельный метод Show, нужно вызывать вручную

print('вызов mult через объект pt4:', pt4.mult(4, 5))  # вызов статического метода mult через объект
print('вызов mult через класс Point:', Point.mult(6, 7))  # вызов статического метода через класс

print('dir модуля: ', dir())
print("dir класса Point: ", dir(Point))

print(pt4.x, pt4.y)
pt4.plus()
print(pt4.x, pt4.y)

